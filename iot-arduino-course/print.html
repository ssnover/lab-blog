<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Internet of Things with Arduino and Python</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="installs.html">Install Prerequisites</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="tutorial/chapter_1_blinking_an_led.html"><strong aria-hidden="true">1.</strong> Blinking an LED</a></li><li class="chapter-item expanded "><a href="tutorial/chapter_2_data_over_serial.html"><strong aria-hidden="true">2.</strong> Reporting Data Over Serial</a></li><li class="chapter-item expanded "><a href="tutorial/chapter_3_pyserial.html"><strong aria-hidden="true">3.</strong> Reading the Serial Port in Python</a></li><li class="chapter-item expanded "><a href="tutorial/chapter_4_temp_data.html"><strong aria-hidden="true">4.</strong> Collecting Temperature Data</a></li><li class="chapter-item expanded "><a href="tutorial/chapter_5_uploading_data.html"><strong aria-hidden="true">5.</strong> Uploading Data to the Database</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="influxdb.html">Demonstration with InfluxDB</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="appendix/hardware.html">A1. Hardware Required</a></li><li class="chapter-item expanded affix "><a href="appendix/influxdb.html">A2. Running InfluxDB</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Internet of Things with Arduino and Python</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-internet-of-things"><a class="header" href="#introduction-to-internet-of-things">Introduction to Internet of Things</a></h1>
<p><em>with Arduino and Python</em></p>
<h2 id="about-the-course"><a class="header" href="#about-the-course">About the Course</a></h2>
<p>This course is an introduction to developing networked embedded systems. It will walk you through writing a program to collect data from a sensor with an Arduino UNO, sending that data to a computer over a serial connection, and then logging that data into a database.</p>
<p>By the end of this tutorial, you'll have a system collecting temperature data and reporting it to a database from which you can view historic plots of the data. This will give you a template from which you can record almost any type of data you could think of and get it into a saved format which can be easily analyzed later or for which actions can be triggered in real-time.</p>
<h3 id="notes-on-using-this-book-asynchronously"><a class="header" href="#notes-on-using-this-book-asynchronously">Notes On Using this Book Asynchronously</a></h3>
<p>I originally wrote and developed this for the purpose of instructing the content live with hardware provided and an instance of the database accessible over LAN. If you're interested in following along remotely, check out the appendix items for a list of hardware you'll need to purchase and a non-comprehensive guide to setting up InfluxDB with Docker.</p>
<h3 id="this-book-is-a-living-document"><a class="header" href="#this-book-is-a-living-document">This Book is a Living Document</a></h3>
<p>If you find a mistake, a broken link, or an opportunity to provide a better explanation, please file an issue on this course's <a href="https://github.com/ssnover/iot-arduino-course/issues">GitHub repository</a>!</p>
<h2 id="knowledge-to-have-before-the-course"><a class="header" href="#knowledge-to-have-before-the-course">Knowledge to Have Before the Course</a></h2>
<p>This course assumes a small amount of prerequisite knowledge. While the content should be accessible if you've not programmed in Python or C++ before (the two languages the provided code are written in), the course will not explain the basics of programming. If you're taking the course with me in person, I've provided the hardware and no changes should be required. However if you're following along remotely, you'll need to be comfortable using a breadboard and perhaps soldering.</p>
<p>If you're new to programming, I suggest following along with the earlier chapters of <code>Automate the Boring Stuff with Python</code> by Al Sweigart. You can find the online version <a href="https://automatetheboringstuff.com/">here</a>. This will instruct you on how to install the tools, basics of programming like variables and functions, and basic concepts about the operating system and resources it makes available to you.</p>
<p>If you've new to electronics, Adafruit has put together a simple guide to getting started with Arduino and electronics in general. Naturally, they'll sell you a kit to do so, but similar kits are also available on Amazon or Sparkfun and from stores like Microcenter. I recommend shopping around as they contain various different kinds of hardware. Adafruit's course can be found <a href="https://learn.adafruit.com/lesson-0-getting-started/overview">here</a>.</p>
<h2 id="a-little-about-myself"><a class="header" href="#a-little-about-myself">A Little About Myself</a></h2>
<p>I've been developing embedded systems in industry for several years now working on smart home systems as well as in robotics. This is a field I've found to be very approachable for hobbyists and students due to the vast amount of information available online and the relatively low monetary cost of entry. I write about my projects in robotics and systems programming <a href="https://shanesnover.com">on my website</a> if you're curious about my other projects or want updates as I write more courses (maybe).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-prerequisites"><a class="header" href="#install-prerequisites">Install Prerequisites</a></h1>
<p>This page will walk you through installing all of the tools required for building the code for the Arduino and running the Python script on your host system.</p>
<h2 id="arduino-ide"><a class="header" href="#arduino-ide">Arduino IDE</a></h2>
<p>I won't repeat too much information here which could easily go out of date and instead refer to Arduino's documentation for <a href="https://support.arduino.cc/hc/en-us/articles/360019833020-Download-and-install-Arduino-IDE">installing the Arduino IDE</a>. Instructions there are available for Windows, macOS, and Linux.</p>
<p>Verify your installation by opening the IDE, creating a new sketch, and navigating the menu to <code>Tools</code> -&gt; <code>Board</code> -&gt; <code>Arduino AVR Boards</code> -&gt; <code>Arduino UNO</code>. This is the board we'll be focusing on in this course. Then select the checkmark button in the top left and verify that the output window eventually finishes printing and shows something like below:</p>
<pre><code>Sketch uses 444 bytes (1%) of program storage space. Maximum is 32256 bytes.
Global variables use 9 bytes (0%) of dynamic memory, leaving 2039 bytes for local variables. Maximum is 2048 bytes.
</code></pre>
<h2 id="python-and-pip"><a class="header" href="#python-and-pip">Python and pip</a></h2>
<p>Similarly, for installing <code>python3</code> and <code>pip</code>, there are great directions available. Here is a link to Python's <a href="https://wiki.python.org/moin/BeginnersGuide/Download">documentation for installation</a> on various operating systems.</p>
<p>Verify your installation in two parts. First, python:</p>
<pre><code>python3 --version
</code></pre>
<p>And then pip:</p>
<pre><code>python3 -m pip -V
</code></pre>
<p>Both commands will print the versions of <code>python3</code> and <code>pip</code> respectively.</p>
<p>Once both of those are installed, create a new folder for your project, something like <code>iot_course</code>, and inside download <a href="https://raw.githubusercontent.com/ssnover/iot-arduino-course/main/complete/mqtt-publisher/requirements.txt">this file</a>. Save it as <code>requirements.txt</code>. Then you can run <code>python3 -m pip install -r requirements.txt</code> from that directory to install the Python libraries we'll be using in this course.</p>
<h2 id="python-development-environment"><a class="header" href="#python-development-environment">Python Development Environment</a></h2>
<p>Feel free to develop and execute the python code in whatever way is most comfortable for you. However, if you've never written python before, I recommend a free program called <code>VSCode</code> for editing and running. Downloads for all platforms <a href="https://code.visualstudio.com/download">are available here</a>.</p>
<p>Once you've finished installing, navigate to the Extensions tab in the left column sidebar (icon shows three blocks together and an additional block by itself). There is an extension by Microsoft for Python which gives convenient ways of running Python scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blinking-an-led"><a class="header" href="#blinking-an-led">Blinking an LED</a></h1>
<p>We'll get started on the Arduino side of things first since that will eventually be the source of the data. This is always a useful first step no matter how experienced you are with embedded systems as it verifies that your compiler and flashing toolchain is functional and that the basics of your hardware setup are correct. Luckily the Arduino UNO has an LED onboard for expressly this purpose.</p>
<p>Open your new sketch in the Arduino IDE, call it <code>temperature_sensor</code> or something like that. This should give you a file with two functions defined: <code>setup</code> and <code>loop</code>. Rather than defining a <code>main</code> function yourself, Arduino typically tries to hide some of these details in their attempt to be more user-friendly. I usually leave the <code>loop</code> function empty and treat <code>setup</code> as my <code>main</code> function. This means you don't need to define every as a global variable (since there's otherwise no way to reference variables in both functions).</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>Let's start with this implementation to get an LED blinking, I'll explain what each line is doing down below.</p>
<pre><code class="language-cpp">void setup() {
    const int LED_PIN = 13;
    pinMode(LED_PIN, OUTPUT);
    bool led_state = false;

    while (true) {
        digitalWrite(LED_PIN, led_state);
        led_state = !led_state;
        delay(5000);
    }
}
</code></pre>
<p>The code can be explained in two parts. First we have the initialization step, making a constant variable with a good name of <code>LED_PIN</code> and assigning it to <code>13</code> since the Arduino's onboard LED is pin <code>D13</code>. We have to configure that GPIO pin on the microcontroller as an output (instead of an input) so that we can set that GPIO pin to logical high or low states (5 volts or 0 volts respectively). This is done with the <code>pinMode</code> function, whose documentation can be found <a href="https://www.arduino.cc/reference/en/language/functions/digital-io/pinmode/">here</a>. Finally, we create a variable to represent the current state of the LED (<code>false</code> meaning off).</p>
<p>Next there's the looping code which will run forever as long as the board is powered (due to <code>while (true) {}</code>). In here, we use <code>digitalWrite</code> to set the LED's pin to our current LED state, then we flip the LED state with boolean logic. Finally, we add a delay since otherwise it would blink so fast that we'd never see it. The <code>delay</code> function takes an argument of milliseconds, so in this case there will be 5 seconds between changes to the LED.</p>
<h2 id="flashing-code-to-the-arduino"><a class="header" href="#flashing-code-to-the-arduino">Flashing Code to the Arduino</a></h2>
<p>Use the Verify (checkmark) to compile the C++ source code (make sure you've chosen your Board first) and wait for a successful compile. If you've missed a semicolon or have another type of syntax error, the Output window on the bottom will show red text explaining the error that prevented compiling. It will also show warnings here in yellow text which can provide clues if your code doesn't function how you expect.</p>
<p>Plug in the board's USB cable to your computer and select the board's port via <code>Tools</code> -&gt; <code>Port</code>. On Windows, it will be something like <code>COM1</code>. On Linux, it will be something like <code>/dev/ttyACM0</code>. On Mac, it will be something like <code>&lt;TODO&gt;</code>. Once the port is chosen, you can flash the board with Upload button (has an <code>-&gt;</code> in its icon).</p>
<p>A successful Upload will have text like this in the Output window:</p>
<pre><code class="language-red">avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.00s

avrdude: Device signature = 0x1e950f (probably m328p)
avrdude: reading input file &quot;/tmp/arduino/sketches/E9A94DB52016B8DEAFA0AB134D40CC04/sketch_sep3a.ino.hex&quot;
avrdude: writing flash (882 bytes):

Writing | ################################################## | 100% 0.14s

avrdude: 882 bytes of flash written

avrdude done.  Thank you.
</code></pre>
<p>You should now see a blinking LED on your Arduino. Verify the period of the blinking matches what you expect with a watch or by counting. You can also change the <code>5000</code> to some other numbers and re-upload to verify that it updated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reporting-data-over-serial"><a class="header" href="#reporting-data-over-serial">Reporting Data Over Serial</a></h1>
<p>Next, we're going to cover getting data off the Arduino and onto devices that talk to it. This is what actually makes an embedded system an Internet of Things (IoT) device. The device needs to be connected, directly or indirectly, to the network in some way such that other applications can make use of the data it produces or send commands to the device.</p>
<p>The technology we'll be making use of here is called serial (or UART if you want to research the details). I'll not be explaining in-depth how serial works here. Instead I'll be focusing exclusively on how we are to use it and what it provides us.</p>
<p>Serial is means of sending data between two devices as a series (keyword here) of bytes. Back in the day, many desktop computers had hardware on board for talking to serial devices directly (using a DB-9 connector), but on modern hardware we usually connect to serial devices over USB. Fortunately, the Arduino has the circuitry on board in order to send serial data over USB.</p>
<p>For this chapter, we'll be looking exclusively at how to send data from the Arduino using serial. We'll use the Arduino IDE's Serial Monitor tool to see the information we send. See the next chapter for writing a program to actually receive that data and do something with it.</p>
<p>From last chapter, we're starting here:</p>
<pre><code class="language-cpp">void setup() {
    // Initialization
    const int LED_PIN = 13;
    pinMode(LED_PIN, OUTPUT);
    bool led_state = false;

    // Main loop
    while (true) {
        digitalWrite(LED_PIN, led_state);
        led_state = !led_state;
        delay(5000);
    }
}
</code></pre>
<p>To the initialization section, we'll be adding some code for setting up the Arduino's serial hardware:</p>
<pre><code class="language-cpp">// Initialization
// --snip--
Serial.begin(115200);
Serial.println();
Serial.println(&quot;info: booting&quot;);

while (true) {
// --snip--
</code></pre>
<p>I've omitted most of the code from before, but make sure to add this new code above the while loop.</p>
<p>Here, we tell the microcontroller to start up the serial port hardware with <code>Serial.begin(115200);</code>. Specifically, we're telling it to start up with a baud rate of 115200 bits per second. This is the frequency of serial communication and you don't need to give it much thought other than to remember that number since it's important that both devices talking serial are operating with the same frequency.</p>
<p>Next, we use the serial port to send some simple text (or strings) to any device listening on the other side. Go ahead and compile (verify) and flash (upload) that code. Then open the Serial Monitor (<code>Tools</code> -&gt; <code>Serial Monitor</code> in the Arduino IDE menu).</p>
<p>In the serial monitor, select <code>115200 baud</code> in the rightmost dropdown menu. If you forget, and have something like <code>9600 baud</code>, you'll probably see some question mark-like characters. You'll also need to hit the button marked &quot;Reset&quot; on your Arduino to see the boot message we added to initialization. This is because connecting the Serial Monitor doesn't actually reboot the program and our program has been running since the flashing completed!</p>
<p>Next up, let's print the status of the LED in our main loop!</p>
<pre><code class="language-cpp">// --snip--
while (true) {
    digitalWrite(LED_PIN, led_state);

    Serial.print(&quot;LED state: &quot;);
    if (led_state) {
        Serial.println(&quot;ON&quot;);
    } else {
        Serial.println(&quot;OFF&quot;);
    }

    led_state = !led_state;
    delay(5000);
}
</code></pre>
<p>Notice that for the first statement I used <code>Serial.print</code> instead of <code>Serial.println</code>! The difference between these two is that <code>println</code> does everything <code>print</code> does, except it also sends a special character sequence which means that the next data sent should be printed on the next line. If you're familiar with strings in C, you'll know that this is either <code>\n</code> or <code>\r\n</code>. The details of that aren't incredibly important just yet, but making use of <code>print</code> and <code>println</code> effectively can make reading data in the Serial Monitor easier.</p>
<p>When you build and run the code, you should see something like this in your Serial Monitor:</p>
<pre><code>info: booting
LED state: OFF
LED state: ON
LED state: OFF
LED state: ON
LED state: OFF
LED state: ON
</code></pre>
<p>Congratulations! You've taken the first steps towards reporting data from hardware to your computer! In the next chapter we'll switch gears and focus on using Python to read that data. The full Arduino code up to this point is shown below:</p>
<pre><code class="language-cpp">void setup() {
    // Initialization
    const int LED_PIN = 13;
    pinMode(LED_PIN, OUTPUT);
    bool led_state = false;

    Serial.begin(115200);
    Serial.println();
    Serial.println(&quot;info: booting&quot;);

    // Main loop
    while (true) {
        digitalWrite(LED_PIN, led_state);
        led_state = !led_state;

        Serial.print(&quot;LED state: &quot;);
        if (led_state) {
            Serial.println(&quot;ON&quot;);
        } else {
            Serial.println(&quot;OFF&quot;);
        }

        delay(5000);
    }
}

void loop() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-the-serial-port-in-python"><a class="header" href="#reading-the-serial-port-in-python">Reading the Serial Port in Python</a></h1>
<p>In this chapter we'll be switching gears to write a host program in Python. Now that we've got serial data being emitted from the Arduino, we'll actually be able to read those bytes and manipulate them on the host side.</p>
<p>Create a new directory for the project, like <code>data_reader</code>, and add a <code>main.py</code> file to it. Download or copy <a href="https://raw.githubusercontent.com/ssnover/iot-arduino-course/main/complete/mqtt-publisher/requirements.txt">this file</a> showing the required packages we'll need for this program. You can then install them into your hosted python environment with <code>python3 -m pip install -r requirements.txt</code> or with your IDE's Python package manager, here's the list of current required libraries:</p>
<pre><code>pyserial==3.5
paho-mqtt==1.6.1
</code></pre>
<p>Inside <code>main.py</code>, we'll start off with a barebones python script:</p>
<pre><code class="language-py">import sys

def main():
    &quot;&quot;&quot;Entrypoint&quot;&quot;&quot;
    tty_path = &quot;/dev/ttyACM0&quot; # Change this to the port from the Arduino IDE
    if len(sys.argv) &gt; 1:
        tty_path = sys.argv[1]
    
    print(f&quot;Connecting to serial port at {tty_path}&quot;)


main()
</code></pre>
<p>At this point, all we're doing is defining a program which prints that it is connecting to a serial device (<code>tty_path</code>). I recommend populating a default for convenience; this should be based on whatever shows up as the Port in the Arduino IDE when the board is plugged in. We'll also parse the command line arguments so that that default can be overridden. The actual port can change depending on what USB port is used and what other devices are plugged in at any given time so this will prevent having to look it up all the time.</p>
<p>As a quick aside, the syntax in the print statement is called an f-string (short for &quot;format string&quot;), which is a little bit newer in python and as a result isn't as common to see in tutorials. It can make print statements a little bit more readable in some cases. This is how it looks with a normal string:</p>
<pre><code class="language-py">print(&quot;Connecting to serial port at {0}&quot;.format(tty_path))
</code></pre>
<p>You can quickly try it for yourself with <code>python3 main.py /dev/ttyACM1</code> and verify that the override is working.</p>
<p>Now for the actual serial communication!</p>
<pre><code class="language-py">import serial # New import for the pyserial library
import sys

def main():
    # --snip--
    print(f&quot;Connecting to serial port at {tty_path}&quot;)

    serial_port = serial.Serial(tty_path, 115200, timeout=1)
    serial_port.reset_input_buffer()

    while True:
        next_line = serial_port.readline()
        if next_line:
            print(next_line)

# --snip--
</code></pre>
<p>Here we're using the pyserial library to get a connection to a serial port specified by its port name. We also specify the baud rate (<code>115200</code> baud) and a timeout. The timeout is specified in seconds and is important so that the program doesn't get stuck. This can happen because below we call <code>serial_port.readline()</code> which will not return until a line of data is ready, <em>unless</em> a timeout is specified in which case it will block for no longer than the timeout.</p>
<p>Since the attempt to read a line from the serial port can timeout, we also have to handle the case where the function timed out and we didn't get any data. So we only print the data if we get some data.</p>
<p>Make sure you've closed the Arduino IDE, then give this program a try! You should see a very similar output to the serial monitor, you've basically reimplemented it in python! You can close the program with <code>Ctrl+C</code>.</p>
<pre><code>Connecting to serial port at /dev/ttyACM0
b'\r\n'
b'info: booting\r\n'
b'LED state: OFF\r\n'
b'LED state: ON\r\n'
b'LED state: OFF\r\n'
b'LED state: ON\r\n'
b'LED state: OFF\r\n'
b'LED state: ON\r\n'
</code></pre>
<p>Obviously, it's got a bit more decoration than the Serial Monitor display. This is how python prints encoded byte data, essentially assuming that it is ASCII. In order to turn it into a regular string, we'll need to decode it and probably remove the newline characters (<code>\r\n</code>). To do that, change <code>print(next_line)</code> to <code>print(next_line.decode().rstrip())</code>.</p>
<p>Before moving on, let's just quickly add some nicer handling for when <code>Ctrl+C</code> is pressed.</p>
<pre><code class="language-py">import serial
import signal # New import
import sys

# Adding a global variable to track whether the program should be running
running = True

def exit_handler(sig, frame):
    &quot;&quot;&quot;
    This function will be called when we press Ctrl+C.
    &quot;&quot;&quot;
    global running
    # Setting the variable to false signals that the program should exit
    running = False


def main():
    # --snip--
    if len(sys.argv) &gt; 1:
        tty_path = sys.argv[1]
    signal.signal(signal.SIGINT, exit_handler)

    # --snip--
    while running:
        next_line = serial_port.readline()
        if next_line:
            print(next_line.decode().rstrip())

    print(&quot;Exiting...&quot;)

# --snip--
</code></pre>
<p>In the above source, we're adding a function which handles a request to exit the program, just using a boolean variable to decide if the program should keep running or not. In our <code>main</code> function we configure the python environment to call our function <code>exit_handler</code> when <code>Ctrl+C</code> is pressed. The term for this is <code>SIGINT</code> so we're mapping from that signal.</p>
<p>In the next chapter, we'll go back to programming the Arduino IDE and actually tackle grabbing real sensor data! Just a quick recap of the full program, which is still quite small at this point:</p>
<pre><code class="language-py">import serial
import signal
import sys

running = True

def exit_handler(sig, frame):
    &quot;&quot;&quot;
    This function will be called when we press Ctrl+C.
    &quot;&quot;&quot;
    global running
    # Setting the variable to false signals that the program should exit
    running = False


def main():
    &quot;&quot;&quot;Entrypoint&quot;&quot;&quot;
    tty_path = &quot;/dev/ttyACM0&quot; # Change this to the port from the Arduino IDE
    if len(sys.argv) &gt; 1:
        tty_path = sys.argv[1]
    print(f&quot;Connecting to serial port at {tty_path}&quot;)

    serial_port = serial.Serial(tty_path, 115200, timeout=10)
    serial_port.reset_input_buffer()

    while running:
        next_line = serial_port.readline()
        if next_line:
            print(next_line.decode().rstrip())

    print(&quot;Exiting...&quot;)


main()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collecting-temperature-data"><a class="header" href="#collecting-temperature-data">Collecting Temperature Data</a></h1>
<p>Now that we've verified sending serial data from the Arduino to our python script, let's read some real data! For this tutorial, we're using an AHT20 temperature sensor which we can read data from via the I2C protocol (pronounced &quot;I squared C&quot; or &quot;I two C&quot;).</p>
<p>For this exercise, we won't focus too heavily on the how of talking to the sensor. If you're interested in those details, you can find them in the <a href="https://files.seeedstudio.com/wiki/Grove-AHT20_I2C_Industrial_Grade_Temperature_and_Humidity_Sensor/AHT20-datasheet-2020-4-16.pdf">datasheet</a>. You can usually find a link to the datasheet on the product page of the store where you bought the sensor.</p>
<p>The first piece of information we need is the I2C address. I2C is a bus protocol where multiple devices can be attached to two signals: the clock line and data line. The address is used so that a device knows that the data being sent on the bus is intended for it. Section 5.3 of the datasheet mentions that the I2C address is <code>0x38</code>, so we'll note that down.</p>
<p><img src="tutorial/library-search-screenshot.png" alt="Library search screenshot" /></p>
<p>Finally, in order to not focus on the low-level details, we'll pull in a library. The Arduino IDE makes this really straightforward with the Library Manager. You can find it under <code>Tools</code> -&gt; <code>Manage Libraries...</code> or in the left-hand sidebar where it has an icon showing a bunch of books. If you type <code>aht</code> into the searchbar of the window that opens, you'll find quite a few options! I just chose the first one <code>AHT20 by dvarrel</code> and clicked the Install button. Once it's successfully installed, let's use it in our program.</p>
<pre><code class="language-cpp">#include &quot;Wire.h&quot; // New library include
#include &quot;AHT20.h&quot; // New library include
#include &lt;stdint.h&gt; // New library include

const uint8_t AHT20_I2C_ADDR(0x38);
</code></pre>
<p>First we'll pull in the Arduino's I2C library with <code>Wire.h</code>, the sensor library with <code>AHT20.h</code>, and finally we'll pull in <code>stdint.h</code> which is a standard C library that defines a bunch of fixed-size types. This allows specifying that a variable is a <code>uint8_t</code> instead of an <code>unsigned int</code>. The former will always be a single byte (8 bits). The latter can change it's size based on the hardware that's being compiled to. Because every byte counts when you're working with hardware and if you send an extra byte the command you send to a sensor won't be understood at all! Define a bunch of constants for the I2C address and the two commands we need to initialize the sensor.</p>
<p>Since we noted the address number of the sensor from the datasheet as <code>0x38</code>, I've also added a constant above the definition of the <code>setup()</code> function.</p>
<p>Next, let's go ahead and start reading data from the sensor!</p>
<pre><code class="language-cpp">// --snip--

void setup() {
    // --snip--
    Serial.println(&quot;info: booting&quot;);
    Wire.begin(); // initializes the Arduino's I2C hardware
    AHT20 aht20(AHT20_I2C_ADDR);

    bool initialized = aht20.begin();
    if (!initialized) {
        Serial.println(&quot;error: could not initialize aht20&quot;);
    } else {
        Serial.println(&quot;info: initialized sensor&quot;);
    }

    while (true) {
        while(!aht20.available()) {
            // If there's no data available, wait a little bit
            delay(10);
        }
        float temperature = aht20.getTemperature();
        Serial.print(&quot;data: &quot;);
        Serial.println(temperature);
        delay(5000);
    }
}

void loop() {}
</code></pre>
<p>If you compile and run, you should now see something like this in your python script or in the Arduino IDE Serial Monitor:</p>
<pre><code>info: booting
debug: sensor ready
info: initialized sensor
data: 25.72
data: 25.71
data: 25.71
data: 28.37
</code></pre>
<p>In the next chapter we'll modify our python program to parse that data from a string in the format <code>&quot;data: 13.37&quot;</code> into a decimal number that can be plotted or have other analysis performed on it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uploading-data-to-the-database"><a class="header" href="#uploading-data-to-the-database">Uploading Data to the Database</a></h1>
<p>In this section we'll take our newly measured temperature data and parse it from the messages we're receiving from the Arduino. That data can then be uploaded into a database, in this case an InfluxDB instance. If you're following along remotely, see the appendix section on running InfluxDB with Docker.</p>
<p>We'll be using MQTT as a means of uploading data into InfluxDB. However the database also supports other means including a REST API, but it requires an API token to use. InfluxDB supports plugins for accepting data records via Telegraf, an associated project, and one of those allows subscribing to certain messages on an MQTT broker.</p>
<h2 id="a-little-about-mqtt"><a class="header" href="#a-little-about-mqtt">A Little About MQTT</a></h2>
<p>MQTT is a means of sending messages between programs whereby the programs agree on a topic name like <code>&quot;temperature_data&quot;</code> and then the programs can publish data on this topic by sending the data to a broker or it can subscribe to data on this topic, again by talking to the broker.</p>
<p>In our case, the Python program will connect to the MQTT broker and send data to it by publishing to a topic. The InfluxDB/Telegraf instance will connect to the MQTT broker as a subscriber so that the broker will send it data. That data gets put into InfluxDB.</p>
<h2 id="using-mqtt-with-python"><a class="header" href="#using-mqtt-with-python">Using MQTT with Python</a></h2>
<p>We'll be using a third party library from Eclipse called <code>paho-mqtt</code> in order to publish data in our python program. It doesn't require much code to get started:</p>
<pre><code class="language-py">import json
import paho.mqtt.client as mqtt
import serial
import signal
import sys

# --snip--

def main():
    # --snip--
    signal.signal(signal.SIGINT, exit_handler)

    mqtt_broker_ip = &quot;192.168.5.100&quot;
    client = mqtt.Client()
    client.connect(mqtt_broker_ip, 1883)
    client.loop_start()

    serial_port = serial.Serial(tty_path, 115200, timeout=1)
    serial_port.reset_input_buffer()

    while running:
        next_line = serial_port.readline()
        if next_line:
            next_line = next_line.decode().rstrip()
            print(next_line)
            if next_line.startswith(&quot;data: &quot;):
                try:
                    temperature = float(next_line[6:].rstrip())
                    name = &quot;ssnover&quot;
                    client.publish(f&quot;/temperature/{name}&quot;, json.dumps({&quot;temperature&quot;: temperature}))
                except ValueError:
                    print(f&quot;error: Could not extract data from {next_line}&quot;)

    client.loop_stop()
    print(&quot;Exiting...&quot;)

# --snip--
</code></pre>
<p>In the above code, we create a new instance of the <code>Client</code> class and connect it to an MQTT broker. I've set <code>mqtt_broker_ip</code> to the IP of the device on my network that's hosting the broker and port 1883, which is the default port for MQTT. </p>
<p>The MQTT library allows the user to handle an event loop in order to gracefully handle incoming messages if you're subscribed to any topics. Since we're not doing here, I've called <code>Client.loop_start()</code> and <code>Client.loop_end()</code> before and after the main loop. This just controls the starting and stopping of an additional thread which does the actual communication with the broker. If you were to leave this out, you'd actually see no data getting sent!</p>
<p>Finally, let's look at actually publishing the data. We know that the format of data messages coming from the Arduino is <code>&quot;data: [DECIMAL NUMBER]&quot;</code> so we first check that the line starts with that expected prefix. If it passes that basic check, we take everything after the prefix, remove any dangling whitespace characters with <code>rstrip()</code>, and then try to convert that to a float as a sanity check. This can throw an exception of <code>ValueError</code> if it's not a valid decimal number so I've just handled that by logging it and moving on. To finally publish, we need the topic name and the data. I use <code>&quot;ssnover/temperature&quot;</code> for the topic for the purpose of the in-person session so I suggest using your name in that pattern as well so the database can be ready to read it. The topic data is just a string format so we convert our temperature data back into a string.</p>
<p>If everything is working correctly, you ought to see the temperature data coming in on the dashboard in the InfluxDB instance, go give it a look!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demonstration-with-influxdb"><a class="header" href="#demonstration-with-influxdb">Demonstration with InfluxDB</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a1-hardware-required"><a class="header" href="#a1-hardware-required">A1. Hardware Required</a></h1>
<p>If you're taking the class session in person, you can pretty much skip this page. This page is just documentation of the Arduino setup for those who are remote and interested in purchasing the hardware necessary to run the code for this course.</p>
<h2 id="list-of-hardware"><a class="header" href="#list-of-hardware">List of Hardware</a></h2>
<p>These will mostly link to Sparkfun because they're local to me, but many of these items can be found on the usual sites including Adafruit, Digikey, Mouser, etc.</p>
<ul>
<li>Arduino UNO R3 (https://www.sparkfun.com/products/11021)</li>
<li>Breadboard (https://www.sparkfun.com/products/12002)</li>
<li>Jumper Wires (https://www.sparkfun.com/products/12795)</li>
<li>AHT20 Breakout Board (https://www.sparkfun.com/products/16618)</li>
</ul>
<p>You'll want to find a place where you can access a soldering iron in order to solder header pins on the breakout board. Check out your local makerspaces or libraries (which sometimes have makerspaces in them these days).</p>
<h2 id="circuit-diagram"><a class="header" href="#circuit-diagram">Circuit Diagram</a></h2>
<p>The circuit is super simple, thanks to Arduino.</p>
<ul>
<li>Arduino 3V3 &lt;--&gt; AHT20 3.3V</li>
<li>Arduino GND &lt;--&gt; AHT20 GND</li>
<li>Arduino SDA &lt;--&gt; AHT20 SDA</li>
<li>Arduino SCL &lt;--&gt; AHT20 SCL</li>
</ul>
<p>Alternatively, Sparkfun is all in on their &quot;QWIIC&quot; connector (just a 4-pin JST connector). You can get a version of the Arduino UNO R3 with a QWIIC connector onboard and QWIIC cables; this will mean no soldering if you can't find that and don't own an iron already.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a2-running-influxdb"><a class="header" href="#a2-running-influxdb">A2. Running InfluxDB</a></h1>
<p>If you're running through this course asynchronously, you'll need to set up some software on your own computer in order to get to the big pay-off. This chapter talks through the set of software services I'll be running on my computer.</p>
<p>This part I'm less capable of ensuring runs on Windows and MacOS. I'm running this on Ubuntu 22.04 desktop edition using Docker version 224.0.4. You can find instructions for installing <code>docker</code> here: https://docs.docker.com/engine/install/ubuntu/</p>
<p>I'll be curt on explanation here and instead point to a repository with a working set of configuration files. The repository hosting them all is here: https://github.com/ssnover/mqtt-influx-config </p>
<p>You can run it while in the root directory with <code>docker compose up -d</code> which will launch three services: an MQTT broker, an Influx timeseries database, and an ingress service for the data that connects the two.</p>
<p>The first time that you run it, you'll be prompted to create an admin user, organization, and bucket on the webpage at <code>http://localhost:8086</code>. You'll also need to generate the API token with the UI. Once you've created these, edit the respective fields in the <code>telegraf.conf</code> file. If you host this for an extended period, make sure not to commit any files containing the API token. Relaunch the services with <code>docker compose down</code> and <code>docker compose up -d</code> and the new configuration should take hold.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
