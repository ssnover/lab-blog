<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Internet of Things with Arduino and Python</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="installs.html">Install Prerequisites</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="tutorial/chapter_1_blinking_an_led.html"><strong aria-hidden="true">1.</strong> Blinking an LED</a></li><li class="chapter-item expanded "><a href="tutorial/chapter_2_data_over_serial.html"><strong aria-hidden="true">2.</strong> Reporting Data Over Serial</a></li><li class="chapter-item expanded "><a href="tutorial/chapter_3_pyserial.html"><strong aria-hidden="true">3.</strong> Reading the Serial Port in Python</a></li><li class="chapter-item expanded "><a href="tutorial/chapter_4_temp_data.html"><strong aria-hidden="true">4.</strong> Collecting Temperature Data</a></li><li class="chapter-item expanded "><a href="tutorial/chapter_5_uploading_data.html"><strong aria-hidden="true">5.</strong> Uploading Data to the Database</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="influxdb.html">Demonstration with InfluxDB</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="appendix/hardware.html">A1. Hardware Required</a></li><li class="chapter-item expanded affix "><a href="appendix/influxdb.html">A2. Running InfluxDB</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Internet of Things with Arduino and Python</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-internet-of-things"><a class="header" href="#introduction-to-internet-of-things">Introduction to Internet of Things</a></h1>
<p><em>with Arduino and Python</em></p>
<h2 id="about-the-course"><a class="header" href="#about-the-course">About the Course</a></h2>
<p>This course is an introduction to developing networked embedded systems. It will walk you through writing a program to collect data from a sensor with an Arduino UNO, sending that data to a computer over a serial connection, and then logging that data into a database.</p>
<p>By the end of this tutorial, you'll have a system collecting temperature data and reporting it to a database from which you can view historic plots of the data. This will give you a template from which you can record almost any type of data you could think of and get it into a saved format which can be easily analyzed later or for which actions can be triggered in real-time.</p>
<h3 id="notes-on-using-this-book-asynchronously"><a class="header" href="#notes-on-using-this-book-asynchronously">Notes On Using this Book Asynchronously</a></h3>
<p>I originally wrote and developed this for the purpose of instructing the content live with hardware provided and an instance of the database accessible over LAN. If you're interested in following along remotely, check out the appendix items for a list of hardware you'll need to purchase and a non-comprehensive guide to setting up InfluxDB with Docker.</p>
<h3 id="this-book-is-a-living-document"><a class="header" href="#this-book-is-a-living-document">This Book is a Living Document</a></h3>
<p>If you find a mistake, a broken link, or an opportunity to provide a better explanation, please file an issue on this course's <a href="https://github.com/ssnover/iot-arduino-course/issues">GitHub repository</a>!</p>
<h2 id="knowledge-to-have-before-the-course"><a class="header" href="#knowledge-to-have-before-the-course">Knowledge to Have Before the Course</a></h2>
<p>This course assumes a small amount of prerequisite knowledge. While the content should be accessible if you've not programmed in Python or C++ before (the two languages the provided code are written in), the course will not explain the basics of programming. If you're taking the course with me in person, I've provided the hardware and no changes should be required. However if you're following along remotely, you'll need to be comfortable using a breadboard and perhaps soldering.</p>
<p>If you're new to programming, I suggest following along with the earlier chapters of <code>Automate the Boring Stuff with Python</code> by Al Sweigart. You can find the online version <a href="https://automatetheboringstuff.com/">here</a>. This will instruct you on how to install the tools, basics of programming like variables and functions, and basic concepts about the operating system and resources it makes available to you.</p>
<p>If you've new to electronics, Adafruit has put together a simple guide to getting started with Arduino and electronics in general. Naturally, they'll sell you a kit to do so, but similar kits are also available on Amazon or Sparkfun and from stores like Microcenter. I recommend shopping around as they contain various different kinds of hardware. Adafruit's course can be found <a href="https://learn.adafruit.com/lesson-0-getting-started/overview">here</a>.</p>
<h2 id="a-little-about-myself"><a class="header" href="#a-little-about-myself">A Little About Myself</a></h2>
<p>I've been developing embedded systems in industry for several years now working on smart home systems as well as in robotics. This is a field I've found to be very approachable for hobbyists and students due to the vast amount of information available online and the relatively low monetary cost of entry. I write about my projects in robotics and systems programming <a href="https://shanesnover.com">on my website</a> if you're curious about my other projects or want updates as I write more courses (maybe).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-prerequisites"><a class="header" href="#install-prerequisites">Install Prerequisites</a></h1>
<p>This page will walk you through installing all of the tools required for building the code for the Arduino and running the Python script on your host system.</p>
<h2 id="arduino-ide"><a class="header" href="#arduino-ide">Arduino IDE</a></h2>
<p>I won't repeat too much information here which could easily go out of date and instead refer to Arduino's documentation for <a href="https://support.arduino.cc/hc/en-us/articles/360019833020-Download-and-install-Arduino-IDE">installing the Arduino IDE</a>. Instructions there are available for Windows, macOS, and Linux.</p>
<p>Verify your installation by opening the IDE, creating a new sketch, and navigating the menu to <code>Tools</code> -&gt; <code>Board</code> -&gt; <code>Arduino AVR Boards</code> -&gt; <code>Arduino UNO</code>. This is the board we'll be focusing on in this course. Then select the checkmark button in the top left and verify that the output window eventually finishes printing and shows something like below:</p>
<pre><code>Sketch uses 444 bytes (1%) of program storage space. Maximum is 32256 bytes.
Global variables use 9 bytes (0%) of dynamic memory, leaving 2039 bytes for local variables. Maximum is 2048 bytes.
</code></pre>
<h2 id="python-and-pip"><a class="header" href="#python-and-pip">Python and pip</a></h2>
<p>Similarly, for installing <code>python3</code> and <code>pip</code>, there are great directions available. Here is a link to Python's <a href="https://wiki.python.org/moin/BeginnersGuide/Download">documentation for installation</a> on various operating systems.</p>
<p>Verify your installation in two parts. First, python:</p>
<pre><code>python3 --version
</code></pre>
<p>And then pip:</p>
<pre><code>python3 -m pip -V
</code></pre>
<p>Both commands will print the versions of <code>python3</code> and <code>pip</code> respectively.</p>
<p>Once both of those are installed, create a new folder for your project, something like <code>iot_course</code>, and inside download <a href="https://raw.githubusercontent.com/ssnover/iot-arduino-course/main/complete/mqtt-publisher/requirements.txt">this file</a>. Save it as <code>requirements.txt</code>. Then you can run <code>python3 -m pip install -r requirements.txt</code> from that directory to install the Python libraries we'll be using in this course.</p>
<h2 id="python-development-environment"><a class="header" href="#python-development-environment">Python Development Environment</a></h2>
<p>Feel free to develop and execute the python code in whatever way is most comfortable for you. However, if you've never written python before, I recommend a free program called <code>VSCode</code> for editing and running. Downloads for all platforms <a href="https://code.visualstudio.com/download">are available here</a>.</p>
<p>Once you've finished installing, navigate to the Extensions tab in the left column sidebar (icon shows three blocks together and an additional block by itself). There is an extension by Microsoft for Python which gives convenient ways of running Python scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blinking-an-led"><a class="header" href="#blinking-an-led">Blinking an LED</a></h1>
<p>We'll get started on the Arduino side of things first since that will eventually be the source of the data. This is always a useful first step no matter how experienced you are with embedded systems as it verifies that your compiler and flashing toolchain is functional and that the basics of your hardware setup are correct. Luckily the Arduino UNO has an LED onboard for expressly this purpose.</p>
<p>Open your new sketch in the Arduino IDE, call it <code>temperature_sensor</code> or something like that. This should give you a file with two functions defined: <code>setup</code> and <code>loop</code>. Rather than defining a <code>main</code> function yourself, Arduino typically tries to hide some of these details in their attempt to be more user-friendly. I usually leave the <code>loop</code> function empty and treat <code>setup</code> as my <code>main</code> function. This means you don't need to define every as a global variable (since there's otherwise no way to reference variables in both functions).</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>Let's start with this implementation to get an LED blinking, I'll explain what each line is doing down below.</p>
<pre><code class="language-cpp">void setup() {
    const int LED_PIN = 13;
    pinMode(LED_PIN, OUTPUT);
    bool led_state = false;

    while (true) {
        digitalWrite(LED_PIN, led_state);
        led_state = !led_state;
        delay(5000);
    }
}
</code></pre>
<p>The code can be explained in two parts. First we have the initialization step, making a constant variable with a good name of <code>LED_PIN</code> and assigning it to <code>13</code> since the Arduino's onboard LED is pin <code>D13</code>. We have to configure that GPIO pin on the microcontroller as an output (instead of an input) so that we can set that GPIO pin to logical high or low states (5 volts or 0 volts respectively). This is done with the <code>pinMode</code> function, whose documentation can be found <a href="https://www.arduino.cc/reference/en/language/functions/digital-io/pinmode/">here</a>. Finally, we create a variable to represent the current state of the LED (<code>false</code> meaning off).</p>
<p>Next there's the looping code which will run forever as long as the board is powered (due to <code>while (true) {}</code>). In here, we use <code>digitalWrite</code> to set the LED's pin to our current LED state, then we flip the LED state with boolean logic. Finally, we add a delay since otherwise it would blink so fast that we'd never see it. The <code>delay</code> function takes an argument of milliseconds, so in this case there will be 5 seconds between changes to the LED.</p>
<h2 id="flashing-code-to-the-arduino"><a class="header" href="#flashing-code-to-the-arduino">Flashing Code to the Arduino</a></h2>
<p>Use the Verify (checkmark) to compile the C++ source code (make sure you've chosen your Board first) and wait for a successful compile. If you've missed a semicolon or have another type of syntax error, the Output window on the bottom will show red text explaining the error that prevented compiling. It will also show warnings here in yellow text which can provide clues if your code doesn't function how you expect.</p>
<p>Plug in the board's USB cable to your computer and select the board's port via <code>Tools</code> -&gt; <code>Port</code>. On Windows, it will be something like <code>COM1</code>. On Linux, it will be something like <code>/dev/ttyACM0</code>. On Mac, it will be something like <code>&lt;TODO&gt;</code>. Once the port is chosen, you can flash the board with Upload button (has an <code>-&gt;</code> in its icon).</p>
<p>A successful Upload will have text like this in the Output window:</p>
<pre><code class="language-red">avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.00s

avrdude: Device signature = 0x1e950f (probably m328p)
avrdude: reading input file &quot;/tmp/arduino/sketches/E9A94DB52016B8DEAFA0AB134D40CC04/sketch_sep3a.ino.hex&quot;
avrdude: writing flash (882 bytes):

Writing | ################################################## | 100% 0.14s

avrdude: 882 bytes of flash written

avrdude done.  Thank you.
</code></pre>
<p>You should now see a blinking LED on your Arduino. Verify the period of the blinking matches what you expect with a watch or by counting. You can also change the <code>5000</code> to some other numbers and re-upload to verify that it updated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reporting-data-over-serial"><a class="header" href="#reporting-data-over-serial">Reporting Data Over Serial</a></h1>
<p>Next, we're going to cover getting data off the Arduino and onto devices that talk to it. This is what actually makes an embedded system an Internet of Things (IoT) device. The device needs to be connected, directly or indirectly, to the network in some way such that other applications can make use of the data it produces or send commands to the device.</p>
<p>The technology we'll be making use of here is called serial (or UART if you want to research the details). I'll not be explaining in-depth how serial works here. Instead I'll be focusing exclusively on how we are to use it and what it provides us.</p>
<p>Serial is means of sending data between two devices as a series (keyword here) of bytes. Back in the day, many desktop computers had hardware on board for talking to serial devices directly (using a DB-9 connector), but on modern hardware we usually connect to serial devices over USB. Fortunately, the Arduino has the circuitry on board in order to send serial data over USB.</p>
<p>For this chapter, we'll be looking exclusively at how to send data from the Arduino using serial. We'll use the Arduino IDE's Serial Monitor tool to see the information we send. See the next chapter for writing a program to actually receive that data and do something with it.</p>
<p>From last chapter, we're starting here:</p>
<pre><code class="language-cpp">void setup() {
    // Initialization
    const int LED_PIN = 13;
    pinMode(LED_PIN, OUTPUT);
    bool led_state = false;

    // Main loop
    while (true) {
        digitalWrite(LED_PIN, led_state);
        led_state = !led_state;
        delay(5000);
    }
}
</code></pre>
<p>To the initialization section, we'll be adding some code for setting up the Arduino's serial hardware:</p>
<pre><code class="language-cpp">// Initialization
// --snip--
Serial.begin(115200);
Serial.println();
Serial.println(&quot;info: booting&quot;);

while (true) {
// --snip--
</code></pre>
<p>I've omitted most of the code from before, but make sure to add this new code above the while loop.</p>
<p>Here, we tell the microcontroller to start up the serial port hardware with <code>Serial.begin(115200);</code>. Specifically, we're telling it to start up with a baud rate of 115200 bits per second. This is the frequency of serial communication and you don't need to give it much thought other than to remember that number since it's important that both devices talking serial are operating with the same frequency.</p>
<p>Next, we use the serial port to send some simple text (or strings) to any device listening on the other side. Go ahead and compile (verify) and flash (upload) that code. Then open the Serial Monitor (<code>Tools</code> -&gt; <code>Serial Monitor</code> in the Arduino IDE menu).</p>
<p>In the serial monitor, select <code>115200 baud</code> in the rightmost dropdown menu. If you forget, and have something like <code>9600 baud</code>, you'll probably see some question mark-like characters. You'll also need to hit the button marked &quot;Reset&quot; on your Arduino to see the boot message we added to initialization. This is because connecting the Serial Monitor doesn't actually reboot the program and our program has been running since the flashing completed!</p>
<p>Next up, let's print the status of the LED in our main loop!</p>
<pre><code class="language-cpp">// --snip--
while (true) {
    digitalWrite(LED_PIN, led_state);

    Serial.print(&quot;LED state: &quot;);
    if (led_state) {
        Serial.println(&quot;ON&quot;);
    } else {
        Serial.println(&quot;OFF&quot;);
    }

    led_state = !led_state;
    delay(5000);
}
</code></pre>
<p>Notice that for the first statement I used <code>Serial.print</code> instead of <code>Serial.println</code>! The difference between these two is that <code>println</code> does everything <code>print</code> does, except it also sends a special character sequence which means that the next data sent should be printed on the next line. If you're familiar with strings in C, you'll know that this is either <code>\n</code> or <code>\r\n</code>. The details of that aren't incredibly important just yet, but making use of <code>print</code> and <code>println</code> effectively can make reading data in the Serial Monitor easier.</p>
<p>When you build and run the code, you should see something like this in your Serial Monitor:</p>
<pre><code>info: booting
LED state: OFF
LED state: ON
LED state: OFF
LED state: ON
LED state: OFF
LED state: ON
</code></pre>
<p>Congratulations! You've taken the first steps towards reporting data from hardware to your computer! In the next chapter we'll switch gears and focus on using Python to read that data. The full Arduino code up to this point is shown below:</p>
<pre><code class="language-cpp">void setup() {
    // Initialization
    const int LED_PIN = 13;
    pinMode(LED_PIN, OUTPUT);
    bool led_state = false;

    Serial.begin(115200);
    Serial.println();
    Serial.println(&quot;info: booting&quot;);

    // Main loop
    while (true) {
        digitalWrite(LED_PIN, led_state);
        led_state = !led_state;

        Serial.print(&quot;LED state: &quot;);
        if (led_state) {
            Serial.println(&quot;ON&quot;);
        } else {
            Serial.println(&quot;OFF&quot;);
        }

        delay(5000);
    }
}

void loop() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-the-serial-port-in-python"><a class="header" href="#reading-the-serial-port-in-python">Reading the Serial Port in Python</a></h1>
<p>In this chapter we'll be switching gears to write a host program in Python. Now that we've got serial data being emitted from the Arduino, we'll actually be able to read those bytes and manipulate them on the host side.</p>
<p>Create a new directory for the project, like <code>data_reader</code>, and add a <code>main.py</code> file to it. Download or copy <a href="https://raw.githubusercontent.com/ssnover/iot-arduino-course/main/complete/mqtt-publisher/requirements.txt">this file</a> showing the required packages we'll need for this program. You can then install them into your hosted python environment with <code>python3 -m pip install -r requirements.txt</code>.</p>
<p>Inside <code>main.py</code>, we'll start off with a barebones python script:</p>
<pre><code class="language-py">import sys

def main():
    &quot;&quot;&quot;Entrypoint&quot;&quot;&quot;
    tty_path = &quot;/dev/ttyACM0&quot; # Change this to the port from the Arduino IDE
    if len(sys.argv) &gt; 1:
        tty_path = sys.argv[1]
    
    print(f&quot;Connecting to serial port at {tty_path}&quot;)


main()
</code></pre>
<p>At this point, all we're doing is defining a program which prints that it is connecting to a serial device (<code>tty_path</code>). I recommend populating a default for convenience; this should be based on whatever shows up as the Port in the Arduino IDE when the board is plugged in. We'll also parse the command line arguments so that that default can be overridden. The actual port can change depending on what USB port is used and what other devices are plugged in at any given time so this will prevent having to look it up all the time.</p>
<p>As a quick aside, the syntax in the print statement is called an f-string (short for &quot;format string&quot;), which is a little bit newer in python and as a result isn't as common to see in tutorials. It can make print statements a little bit more readable in some cases. This is how it looks with a normal string:</p>
<pre><code class="language-py">print(&quot;Connecting to serial port at {0}&quot;.format(tty_path))
</code></pre>
<p>You can quickly try it for yourself with <code>python3 main.py /dev/ttyACM1</code> and verify that the override is working.</p>
<p>Now for the actual serial communication!</p>
<pre><code class="language-py">import serial # New import for the pyserial library
import sys

def main():
    # --snip--
    print(f&quot;Connecting to serial port at {tty_path}&quot;)

    serial_port = serial.Serial(tty_path, 115200, timeout=1)
    serial_port.reset_input_buffer()

    while True:
        next_line = serial_port.readline()
        if next_line:
            print(next_line)

# --snip--
</code></pre>
<p>Here we're using the pyserial library to get a connection to a serial port specified by its port name. We also specify the baud rate (<code>115200</code> baud) and a timeout. The timeout is specified in seconds and is important so that the program doesn't get stuck. This can happen because below we call <code>serial_port.readline()</code> which will not return until a line of data is ready, <em>unless</em> a timeout is specified in which case it will block for no longer than the timeout.</p>
<p>Since the attempt to read a line from the serial port can timeout, we also have to handle the case where the function timed out and we didn't get any data. So we only print the data if we get some data.</p>
<p>Make sure you've closed the Arduino IDE, then give this program a try! You should see a very similar output to the serial monitor, you've basically reimplemented it in python! You can close the program with <code>Ctrl+C</code>.</p>
<pre><code>Connecting to serial port at /dev/ttyACM0
b'\r\n'
b'info: booting\r\n'
b'LED state: OFF\r\n'
b'LED state: ON\r\n'
b'LED state: OFF\r\n'
b'LED state: ON\r\n'
b'LED state: OFF\r\n'
b'LED state: ON\r\n'
</code></pre>
<p>Obviously, it's got a bit more decoration than the Serial Monitor display. This is how python prints encoded byte data, essentially assuming that it is ASCII. In order to turn it into a regular string, we'll need to decode it and probably remove the newline characters (<code>\r\n</code>). To do that, change <code>print(next_line)</code> to <code>print(next_line.decode().rstrip())</code>.</p>
<p>Before moving on, let's just quickly add some nicer handling for when <code>Ctrl+C</code> is pressed.</p>
<pre><code class="language-py">import serial
import signal # New import
import sys

# Adding a global variable to track whether the program should be running
running = True

def exit_handler(sig, frame):
    &quot;&quot;&quot;
    This function will be called when we press Ctrl+C.
    &quot;&quot;&quot;
    global running
    # Setting the variable to false signals that the program should exit
    running = False


def main():
    # --snip--
    if len(sys.argv) &gt; 1:
        tty_path = sys.argv[1]
    signal.signal(signal.SIGINT, exit_handler)

    # --snip--
    while running:
        next_line = serial_port.readline()
        if next_line:
            print(next_line.decode().rstrip())

    print(&quot;Exiting...&quot;)

# --snip--
</code></pre>
<p>In the above source, we're adding a function which handles a request to exit the program, just using a boolean variable to decide if the program should keep running or not. In our <code>main</code> function we configure the python environment to call our function <code>exit_handler</code> when <code>Ctrl+C</code> is pressed. The term for this is <code>SIGINT</code> so we're mapping from that signal.</p>
<p>In the next chapter, we'll go back to programming the Arduino IDE and actually tackle grabbing real sensor data! Just a quick recap of the full program, which is still quite small at this point:</p>
<pre><code class="language-py">import serial
import signal
import sys

running = True

def exit_handler(sig, frame):
    &quot;&quot;&quot;
    This function will be called when we press Ctrl+C.
    &quot;&quot;&quot;
    global running
    # Setting the variable to false signals that the program should exit
    running = False


def main():
    &quot;&quot;&quot;Entrypoint&quot;&quot;&quot;
    tty_path = &quot;/dev/ttyACM0&quot; # Change this to the port from the Arduino IDE
    if len(sys.argv) &gt; 1:
        tty_path = sys.argv[1]
    print(f&quot;Connecting to serial port at {tty_path}&quot;)

    serial_port = serial.Serial(tty_path, 115200, timeout=10)
    serial_port.reset_input_buffer()

    while running:
        next_line = serial_port.readline()
        if next_line:
            print(next_line.decode().rstrip())

    print(&quot;Exiting...&quot;)


main()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collecting-temperature-data"><a class="header" href="#collecting-temperature-data">Collecting Temperature Data</a></h1>
<p>Now that we've verified sending serial data from the Arduino to our python script, let's read some real data! For this tutorial, we're using an AHT20 temperature sensor which we can read data from via the I2C protocol (pronounced &quot;I squared C&quot; or &quot;I two C&quot;).</p>
<p>For legal reasons that I won't pretend to understand comprehensively, there are a number of &quot;I2C-compatible&quot; protocols and devices which implement the same protocol but are just called different things. For the Atmega328 (the microcontroller running on the Arduino UNO), it's called two-wire interface (TWI), but pretty much everywhere you'll see it referred to as I2C.</p>
<p>There's a <a href="https://github.com/adafruit/Adafruit_AHTX0">library from Adafruit</a> for the sensor used here. However, this is fairly simple sensor so we'll roll our own as an exercise in reading a datasheet for a device like this. An online copy of the datasheet is <a href="https://files.seeedstudio.com/wiki/Grove-AHT20_I2C_Industrial_Grade_Temperature_and_Humidity_Sensor/AHT20-datasheet-2020-4-16.pdf">here</a>. You can usually find a link to the datasheet on the product page of the store where you bought the sensor.</p>
<p>In the datasheet, the sections we're interested in are Section 5 which describes the commands used to communicate with the sensor and Section 6 which describes how to take the raw binary number reported by the sensor and turn it into a temperature in degrees Celsius. I'll be referring to these sections throughout the chapter.</p>
<p>The first piece of information we need is the I2C address. I2C is a bus protocol where multiple devices can be attached to two signals: the clock line and data line. The address is used so that a device knows that the data being sent on the bus is intended for it. Section 5.3 mentions that the I2C address is <code>0x38</code>.</p>
<p>With the address, this device also accepts certain commands which are each represented with a byte. The same section includes a table of the commands. The relevant ones for us are &quot;Initialization&quot; and &quot;Trigger measurement&quot;, we'll ignore the last one. Reading the next section, 5.4, actually reveals an additional command which will be important, getting the status register. A lot of these datasheets are pretty poorly written and this is a pretty good example. That's another reason to find a library if one exists, to use it as a reference when something in the datasheet doesn't make sense.</p>
<p>The initialization process called for is to wait for 40 ms for the device to power up, then check the status byte. If bit 3 of the status byte is set (or it's a <code>1</code>), then it is calibrated. If not, we need to calibrate it with the Initialization command.</p>
<p>Now let's implement what we've read out of the datasheet:</p>
<pre><code class="language-cpp">#include &quot;Wire.h&quot;
#include &lt;stdint.h&gt;

const uint8_t AHT20_I2C_ADDR(0x38);
const uint8_t GET_STATUS(0x71);
const uint8_t CALIBRATE_CMD(0xbe);
const unsigned int SENSOR_INIT_DELAY(40);
const unsigned int SENSOR_CALIBRATION_DELAY(10);
</code></pre>
<p>First we'll pull in the Arduino's I2C library with in <code>Wire.h</code> and we'll pull in <code>stdint.h</code> which is a standard C library that defines a bunch of fixed-size types. This allows specifying that a variable is a <code>uint8_t</code> instead of an <code>unsigned int</code>. The former will always be a single byte (8 bits). The latter can change it's size based on the hardware that's being compiled to. Because every byte counts when you're working with hardware and if you send an extra byte the command you send to a sensor won't be understood at all! Define a bunch of constants for the I2C address and the two commands we need to initialize the sensor.</p>
<p>Next we'll write a function to get the status since that's the first thing we need to do:</p>
<pre><code class="language-cpp">uint8_t get_status(uint8_t address) {
    Wire.requestFrom(address, 1);
    while (!Wire.available()) {
        delay(1);
    }
    uint8_t status = Wire.read();
    return status;
}
</code></pre>
<p>Since we're getting the status from the sensor, we're doing a read command with <code>Wire.requestFrom()</code>. We pass the address of the device we're talking to and the number of bytes we want back from the device. Then we have to wait for the response. You can call <code>Wire.available()</code> to check if there's any data that's been received (it actually returns the number of bytes received), then read it with <code>Wire.read()</code>.</p>
<p>Next we'll use this to implement an initialization function:</p>
<pre><code class="language-cpp">void init_aht20_sensor(uint8_t address) {
    delay(SENSOR_INIT_DELAY);
    
    uint8_t status = get_status(address);
    bool is_calibrated = status &amp; (1u &lt;&lt; 3);

    if (!is_calibrated) {
        const uint8_t cmd_buffer[3] = {CALIBRATE_CMD, 0x08, 0x00};
        Serial.println(&quot;debug: calibrating sensor&quot;);

        Wire.beginTransmission(address);
        Wire.write(&amp;cmd_buffer[0], 3);
        Wire.endTransmission();
        
        delay(SENSOR_CALIBRATION_DELAY);
    }

    Serial.println(&quot;debug: sensor ready&quot;);
}
</code></pre>
<p>So we first call the function we just implemented <code>get_status()</code>, however that just returns a byte. In order to get the value of a specific bit, we'll need to do some bit-level logic and masking. These aren't commonly used in desktop programs so I'll go into a little more detail here. First the rightmost expression, <code>(1u &lt;&lt; 3)</code>. This takes a value of <code>0b0001</code> in binary and applies a shift left of 3 bit positions. If we shift the bits to the left 3 times, that <code>0b0001</code> becomes <code>0b1000</code>. Zeroes fill in the spots where a new value is required (below bit 0). </p>
<p>Next we do a bit-wise logical AND between this value (the bitmask) and the status byte. That looks like <code>status &amp; 0b0000_1000</code>. Anything ANDed with 0 is 0 and anything ANDed with 1 is itself. So the result of that entire expression can be expressed as <code>0b0000_x000</code> where x is 1 or 0 depending on if the sensor is calibrated or not. If it's a 1, casting this to a <code>bool</code> will give it a value of <code>true</code>, otherwise it will be <code>false</code>.</p>
<p>In the case where it's not calibrated, we need to send a calibration command. The datasheet describes it as a 3 bytes: the calibration command byte followed by <code>0x08 0x00</code>. Writing data to a sensor is a little more verbose. Start a write with <code>Wire.beginTransmission()</code>, write the data buffer of 3 bytes with <code>Wire.write()</code>, then end it with <code>Wire.endTransmission()</code>.</p>
<p>That should be sufficient to initialize the sensor, let's add it to our program:</p>
<pre><code class="language-cpp">// --snip--

void init_aht20_sensor(uint8_t address);
uint8_t get_status(uint8_t address);

void setup() {
    // --snip--
    Serial.println(&quot;info: booting&quot;);

    Wire.begin();
    init_aht20_sensor(AHT20_I2C_ADDR);
    Serial.println(&quot;info: initialized sensor&quot;);

    while (true) {
        // --snip--
    }
}

void init_aht20_sensor(uint8_t address) {
    // --snip--
}

uint8_t get_status(uint8_t address) {
    // --snip--
}
</code></pre>
<p>To wrap up the integration of the initialization routine, we just add a call to <code>Wire.begin()</code> to initialize the Arduino's I2C hardware similar to serial's <code>Serial.begin()</code>, then call our function.</p>
<p>I recommend building and running the code really quick to verify you've got it working (and/or that the wiring between the Arduino and the sensor is correct). In your python program, you should see:</p>
<pre><code>info: booting
debug: calibrating sensor // this may be missing as it won't always be required
debug: sensor ready
info: initialized sensor
LED state: OFF
LED state: ON
LED state: OFF 
</code></pre>
<p>With the initialization out of the way, let's read some data. The figure in the datasheet shows the contents and length of the data to be read back. This sensor measures both temperature and humidity so the measurement will contain both values. Out of the bytes returned the temperature data can be found in the 4th, 5th, and 6th byte and it has a size of 20 bits. The next size type up is a <code>uint32_t</code> so we'll plan to store it in that.</p>
<pre><code class="language-cpp">const uint8_t TRIGGER_CMD(0xac);

// --snip--

float request_temperature_data(uint8_t address) {
    // send a command
    const uint8_t cmd_buffer[3] = {TRIGGER_CMD, 0x33, 0x00};
    Wire.beginTransmission(address);
    Wire.write(&amp;cmd_buffer[0], 3);
    Wire.endTransmission();

    bool data_available = false;
    while (!data_available) {
        delay(10);
        uint8_t status = get_status(address);
        if (!(status &amp; (1u &lt;&lt; 7))) {
            data_available = true;
        }
    }

    // --snip next section--
}
</code></pre>
<p>First we need to send the command to trigger a measurement which is very similar to the calibrate command. The measurement takes some time to complete and we can determine when it's done by reading the status byte again. This time it's bit 7 instead of bit 3 so we adjust the masking appropriately, but there's one extra complication: 1 in this position indicates the sensor is busy and 0 means it's done, so we need to invert the logic. Be careful with the placement of your parentheses here, these can be very difficult problems to debug. I once had a bug that took several days to find because I had <code>~byte</code> instead of <code>!byte</code> (bitwise NOT instead of boolean NOT). We'll just loop until data is available.</p>
<pre><code class="language-cpp">float request_temperature_data(uint8_t address) {
    // --snip previous section--

    const uint8_t READING_BYTES = 7;
    uint8_t reading[READING_BYTES] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    Wire.requestFrom(address, READING_BYTES);
    for (auto bytes_read = 0u; bytes_read &lt; READING_BYTES; ++bytes_read) {
        if (Wire.available()) {
            reading[bytes_read] = Wire.read();
        } else {
            delay(1);
        }
    }

    // --snip next section--
}
</code></pre>
<p>Then we can proceed to read the raw data from the sensor. The datasheet mentions that the payload size if 7 bytes and we've already determined which of those bytes we're interested in, but we'll just read them all. We loop through and fill a buffer.</p>
<pre><code class="language-cpp">float request_temperature_data(uint8_t address) {
    // --snip previous section--

    uint32_t raw = ((uint32_t)(reading[3] &amp; 0b00001111) &lt;&lt; 16);
    raw |= ((uint32_t)reading[4] &lt;&lt; 8);
    raw |= reading[5];
    float temperature = calculate_temperature_from_raw(raw);
    return temperature;
}
</code></pre>
<p>The last part is the most complicated. The first part to notice is the the 4th byte (<code>reading[3]</code>) actually contains temperature and humidity data. We only want the lowest 4 bits on account of this. But are these the lowest 4 bits of the temperature data or the highest 4 bits? The datasheet is remarkably unhelpful here, but it appears to follow convention: big-endian for protocol data. That means the most significant bytes are sent first. If you're ever unsure, try one way and see how the value changes at rest. If it's backwards, you'll see rapid swings in the data as the least significant bits will change frequently with noise on the sensor and they're in the wrong position.</p>
<p>Since the 4 bits are the most significant, after masking them we'll shift them 16 places to leave room for the remaining 16 bits. Before we can shift though, we need to make sure the data being shifted fits into a data type that can fit all of the bits (remember that <code>reading</code> is an array of bytes). We can do so by casting the data to a 32-bit wide type with <code>(uint32_t)(data)</code>. Then we continue building up our raw measurement value with the two other bytes, which do not require masking. The syntax <code>raw |= data;</code> is shorthand for <code>raw = raw | data</code> and since we left space there, this will make that region of the data equal to the byte we're reading from.</p>
<p>Our raw data isn't very useful as it's quite hard to read and understand, so we'll take one last step and calculate the temperature in units of degrees Celsius. We'll be referring to Section 6.2 of the datasheet for the formula.</p>
<pre><code class="language-cpp">float calculate_temperature_from_raw(uint32_t raw_data) {
    // See Section 6.2
    auto ratio = static_cast&lt;float&gt;(raw_data) / (1ul &lt;&lt; 20);
    ratio *= 200.;
    ratio -= 50.;
    return ratio;
}
</code></pre>
<p>The first step of the calculation involves dividing by the full possible resolution, effectively giving us a value between 0.0 and 1.0. We'll need to cast the data to a floating point value which can represent decimals, otherwise the result will always be 0. Note that I'm using shifting for the denominator again. In binary, shifting a number to the left by 1 is equivalent to multiplying it by 2, just as shifting a number to the left in decimal one place is equivalent to multiplying by 10.</p>
<p>Then we just multiply by 200 and subtract 50. This means the full range of temperature values that it's possible for the sensor to represent is -50 C to 150 C.</p>
<p>Let's add the measurement code to our program's mainloop!</p>
<pre><code class="language-cpp">void setup() {
    // --snip--

    while (true) {
        digitalWrite(LED_PIN, led_state);
        led_state = !led_state;

        float temperature = request_temperature_data(AHT20_I2C_ADDR);
        Serial.print(&quot;data: &quot;);
        Serial.println(temperature);
        delay(5000);
    }
}
</code></pre>
<p>I've removed the logging of the LED state as it's not very useful for our python program. We'll let the LED continue to blink though since it can be useful to know if the program is running at a glance.</p>
<p>That's it! If you run your python program or check the Serial Monitor, you should see temperature values being reported in the terminal!</p>
<pre><code>info: booting
debug: sensor ready
info: initialized sensor
data: 25.72
data: 25.71
data: 25.71
data: 28.37
</code></pre>
<p>In the next chapter we'll modify our python program to parse that data from a string in the format <code>&quot;data: 19.4&quot;</code> into a decimal number that can be plotted or have other analysis performed on it.</p>
<p>Here's the completed Arduino program:</p>
<pre><code class="language-cpp">#include &quot;Wire.h&quot;
#include &lt;stdint.h&gt;

const uint8_t AHT20_I2C_ADDR(0x38);
const uint8_t GET_STATUS(0x71);
const uint8_t CALIBRATE_CMD(0xbe);
const uint8_t TRIGGER_CMD(0xac);
const unsigned int SENSOR_INIT_DELAY(40);
const unsigned int SENSOR_CALIBRATION_DELAY(10);

void setup() {
    // Initialization
    const int LED_PIN = 13;
    pinMode(LED_PIN, OUTPUT);
    bool led_state = false;

    Serial.begin(115200);
    Serial.println();
    Serial.println(&quot;info: booting&quot;);

    Wire.begin();
    init_aht20_sensor(AHT20_I2C_ADDR);
    Serial.println(&quot;info: initialized sensor&quot;);

    while (true) {
        digitalWrite(LED_PIN, led_state);
        led_state = !led_state;

        float temperature = request_temperature_data(AHT20_I2C_ADDR);
        Serial.print(&quot;data: &quot;);
        Serial.println(temperature);
        delay(5000);
    }
}

uint8_t get_status(uint8_t address) {
    Wire.requestFrom(address, 1);
    while (!Wire.available()) {
        delay(1);
    }
    uint8_t status = Wire.read();
    return status;
}

void init_aht20_sensor(uint8_t address) {
    delay(SENSOR_INIT_DELAY);
    
    uint8_t status = get_status(address);
    bool is_calibrated = status &amp; (1u &lt;&lt; 3);

    if (!is_calibrated) {
        const uint8_t cmd_buffer[3] = {CALIBRATE_CMD, 0x08, 0x00};
        Serial.println(&quot;debug: calibrating sensor&quot;);

        Wire.beginTransmission(address);
        Wire.write(&amp;cmd_buffer[0], 3);
        Wire.endTransmission();
        
        delay(SENSOR_CALIBRATION_DELAY);
    }

    Serial.println(&quot;debug: sensor ready&quot;);
}

float request_temperature_data(uint8_t address) {
    // send a command
    const uint8_t cmd_buffer[3] = {TRIGGER_CMD, 0x33, 0x00};
    Wire.beginTransmission(address);
    Wire.write(&amp;cmd_buffer[0], 3);
    Wire.endTransmission();

    bool data_available = false;
    while (!data_available) {
        delay(10);
        uint8_t status = get_status(address);
        if (!(status &amp; (1u &lt;&lt; 7))) {
            data_available = true;
        }
    }

    const uint8_t READING_BYTES = 7;
    uint8_t reading[READING_BYTES] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    Wire.requestFrom(address, READING_BYTES);
    for (auto bytes_read = 0u; bytes_read &lt; READING_BYTES; ++bytes_read) {
        if (Wire.available()) {
            reading[bytes_read] = Wire.read();
        } else {
            delay(1);
        }
    }

    uint32_t raw = ((uint32_t)(reading[3] &amp; 0b00001111) &lt;&lt; 16);
    raw |= ((uint32_t)reading[4] &lt;&lt; 8);
    raw |= reading[5];
    float temperature = calculate_temperature_from_raw(raw);
    return temperature;
}

float calculate_temperature_from_raw(uint32_t raw_data) {
    // See Section 6.2
    auto ratio = static_cast&lt;float&gt;(raw_data) / (1ul &lt;&lt; 20);
    ratio *= 200.;
    ratio -= 50.;
    return ratio;
}

void loop() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uploading-data-to-the-database"><a class="header" href="#uploading-data-to-the-database">Uploading Data to the Database</a></h1>
<p>In this section we'll take our newly measured temperature data and parse it from the messages we're receiving from the Arduino. That data can then be uploaded into a database, in this case an InfluxDB instance. If you're following along remotely, see the appendix section on running InfluxDB with Docker.</p>
<p>We'll be using MQTT as a means of uploading data into InfluxDB. However the database also supports other means including a REST API, but it requires an API token to use. InfluxDB supports plugins for accepting data records via Telegraf, an associated project, and one of those allows subscribing to certain messages on an MQTT broker.</p>
<h2 id="a-little-about-mqtt"><a class="header" href="#a-little-about-mqtt">A Little About MQTT</a></h2>
<p>MQTT is a means of sending messages between programs whereby the programs agree on a topic name like <code>&quot;temperature_data&quot;</code> and then the programs can publish data on this topic by sending the data to a broker or it can subscribe to data on this topic, again by talking to the broker.</p>
<p>In our case, the Python program will connect to the MQTT broker and send data to it by publishing to a topic. The InfluxDB/Telegraf instance will connect to the MQTT broker as a subscriber so that the broker will send it data. That data gets put into InfluxDB.</p>
<h2 id="using-mqtt-with-python"><a class="header" href="#using-mqtt-with-python">Using MQTT with Python</a></h2>
<p>We'll be using a third party library from Eclipse called <code>paho-mqtt</code> in order to publish data in our python program. It doesn't require much code to get started:</p>
<pre><code class="language-py">import json
import paho.mqtt.client as mqtt
import serial
import signal
import sys

# --snip--

def main():
    # --snip--
    signal.signal(signal.SIGINT, exit_handler)

    nqtt_broker_ip = &quot;192.168.5.100&quot;
    client = mqtt.Client()
    client.connect(mqtt_broker_ip, 1883)
    client.loop_start()

    serial_port = serial.Serial(tty_path, 115200, timeout=1)
    serial_port.reset_input_buffer()

    while running:
        next_line = serial_port.readline()
        if next_line:
            next_line = next_line.decode().rstrip()
            print(next_line)
            if next_line.startswith(&quot;data: &quot;):
                try:
                    temperature = float(next_line[6:].rstrip())
                    name = &quot;ssnover&quot;
                    client.publish(f&quot;/temperature/{name}&quot;, json.dumps({&quot;temperature&quot;: temperature}))
                except ValueError:
                    print(f&quot;error: Could not extract data from {next_line}&quot;)

    client.loop_stop()
    print(&quot;Exiting...&quot;)

# --snip--
</code></pre>
<p>In the above code, we create a new instance of the <code>Client</code> class and connect it to an MQTT broker. I've set <code>mqtt_broker_ip</code> to the IP of the device on my network that's hosting the broker and port 1883, which is the default port for MQTT. </p>
<p>The MQTT library allows the user to handle an event loop in order to gracefully handle incoming messages if you're subscribed to any topics. Since we're not doing here, I've called <code>Client.loop_start()</code> and <code>Client.loop_end()</code> before and after the main loop. This just controls the starting and stopping of an additional thread which does the actual communication with the broker. If you were to leave this out, you'd actually see no data getting sent!</p>
<p>Finally, let's look at actually publishing the data. We know that the format of data messages coming from the Arduino is <code>&quot;data: [DECIMAL NUMBER]&quot;</code> so we first check that the line starts with that expected prefix. If it passes that basic check, we take everything after the prefix, remove any dangling whitespace characters with <code>rstrip()</code>, and then try to convert that to a float as a sanity check. This can throw an exception of <code>ValueError</code> if it's not a valid decimal number so I've just handled that by logging it and moving on. To finally publish, we need the topic name and the data. I use <code>&quot;ssnover/temperature&quot;</code> for the topic for the purpose of the in-person session so I suggest using your name in that pattern as well so the database can be ready to read it. The topic data is just a string format so we convert our temperature data back into a string.</p>
<p>If everything is working correctly, you ought to see the temperature data coming in on the dashboard in the InfluxDB instance, go give it a look!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demonstration-with-influxdb"><a class="header" href="#demonstration-with-influxdb">Demonstration with InfluxDB</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a1-hardware-required"><a class="header" href="#a1-hardware-required">A1. Hardware Required</a></h1>
<p>If you're taking the class session in person, you can pretty much skip this page. This page is just documentation of the Arduino setup for those who are remote and interested in purchasing the hardware necessary to run the code for this course.</p>
<h2 id="list-of-hardware"><a class="header" href="#list-of-hardware">List of Hardware</a></h2>
<p>These will mostly link to Sparkfun because they're local to me, but many of these items can be found on the usual sites including Adafruit, Digikey, Mouser, etc.</p>
<ul>
<li>Arduino UNO R3 (https://www.sparkfun.com/products/11021)</li>
<li>Breadboard (https://www.sparkfun.com/products/12002)</li>
<li>Jumper Wires (https://www.sparkfun.com/products/12795)</li>
<li>AHT20 Breakout Board (https://www.sparkfun.com/products/16618)</li>
</ul>
<p>You'll want to find a place where you can access a soldering iron in order to solder header pins on the breakout board. Check out your local makerspaces or libraries (which sometimes have makerspaces in them these days).</p>
<h2 id="circuit-diagram"><a class="header" href="#circuit-diagram">Circuit Diagram</a></h2>
<p>The circuit is super simple, thanks to Arduino.</p>
<ul>
<li>Arduino 3V3 &lt;--&gt; AHT20 3.3V</li>
<li>Arduino GND &lt;--&gt; AHT20 GND</li>
<li>Arduino SDA &lt;--&gt; AHT20 SDA</li>
<li>Arduino SCL &lt;--&gt; AHT20 SCL</li>
</ul>
<p>Alternatively, Sparkfun is all in on their &quot;QWIIC&quot; connector (just a 4-pin JST connector). You can get a version of the Arduino UNO R3 with a QWIIC connector onboard and QWIIC cables; this will mean no soldering if you can't find that and don't own an iron already.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a2-running-influxdb"><a class="header" href="#a2-running-influxdb">A2. Running InfluxDB</a></h1>
<p>If you're running through this course asynchronously, you'll need to set up some software on your own computer in order to get to the big pay-off. This chapter talks through the set of software services I'll be running on my computer.</p>
<p>This part I'm less capable of ensuring runs on Windows and MacOS. I'm running this on Ubuntu 22.04 desktop edition using Docker version 224.0.4. You can find instructions for installing <code>docker</code> here: https://docs.docker.com/engine/install/ubuntu/</p>
<p>I'll be curt on explanation here and instead point to a repository with a working set of configuration files. The repository hosting them all is here: https://github.com/ssnover/mqtt-influx-config </p>
<p>You can run it while in the root directory with <code>docker compose up -d</code> which will launch three services: an MQTT broker, an Influx timeseries database, and an ingress service for the data that connects the two.</p>
<p>The first time that you run it, you'll be prompted to create an admin user, organization, and bucket on the webpage at <code>http://localhost:8086</code>. You'll also need to generate the API token with the UI. Once you've created these, edit the respective fields in the <code>telegraf.conf</code> file. If you host this for an extended period, make sure not to commit any files containing the API token. Relaunch the services with <code>docker compose down</code> and <code>docker compose up -d</code> and the new configuration should take hold.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
